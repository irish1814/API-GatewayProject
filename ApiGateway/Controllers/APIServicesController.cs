using Microsoft.AspNetCore.Mvc;
using System.Text.Json;
using ApiGateway.Models.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.AI;


namespace ApiGateway.Controllers
{
    /// <summary>
    /// Controller responsible for handling API service calls including interaction with AI agents
    /// and cryptocurrency price tracking.
    /// Use this API through // http://localhost:5182/api/APIServices
    /// </summary>
    [Route("api/[controller]")]
    [ApiController]
    public class APIServicesController : Controller
    {
        private readonly CryptoDbContext _db;

        /// <summary>
        /// Initializes a new instance of the <see cref="UsersController"/> class with the specified database context.
        /// </summary>
        /// <param name="db">The database context used to access user data.</param>
        public APIServicesController(CryptoDbContext db)
        {
            _db = db;
        }

        /// <summary>
        /// Sends a prompt to a local TinyLlama model running at http://localhost:11434/api/generate
        /// and returns the AI-generated response.
        /// </summary>
        /// <param name="prompt">The prompt string to be processed by the AI agent.</param>
        /// <returns>Returns the response generated by the AI model or an error if the request fails.</returns>
        [HttpPost("Agent")]
        public async Task<IActionResult> AskLAIAgent([FromForm] string prompt, [FromHeader(Name = "X-Api-Key")] string apiKey)
        {
            var user = await GetUserByApiKeyAsync(apiKey);
            if (user == null)
                return Unauthorized("Invalid or missing API key: X-Api-Key=YOUR-API-KEY");

            IChatClient chatClient = new OllamaChatClient(endpoint: new Uri("http://192.168.33.51:11434"), modelId: "tinyllama:latest");
            List<ChatMessage> chatHistory = [];

            chatHistory.Add(new ChatMessage(ChatRole.User, prompt));

            var response = "AI Agent Response: ";

            await foreach (var item in chatClient.GetStreamingResponseAsync(chatHistory))
            {
                Console.Write(item.Text);
                response += item.Text;
            }

            chatHistory.Add(new ChatMessage(ChatRole.Assistant, response));
            Console.WriteLine();

            return Ok(new { AgentResponse = response });
        }

        /// <summary>
        /// Fetches the current information of a cryptocurrency from the Coinlore API based on its ID,
        /// stores the price and symbol in memory, and logs the history to the console.
        /// </summary>
        /// <param name="id">The Coinlore ID of the cryptocurrency.</param>
        /// <returns>
        /// Returns the API response as-is if successful. Also appends the current price and symbol to
        /// the local in-memory history list.
        /// </returns>
        [HttpPost("Currency")]
        public async Task<IActionResult> GetCryptoCurrencyInfo([FromForm] int id, [FromHeader(Name = "X-Api-Key")] string apiKey)
        {
            // Look up user by apiKey in the database
            var user = await _db.Users.FirstOrDefaultAsync(u => u.ApiKey.ToString() == apiKey);
            if (user == null)
            {
                return Unauthorized("Invalid or missing API key: X-Api-Key=YOUR-API-KEY");
            }

            // Step 1: Fetch Currency data from CoinLore
            var client = new HttpClient();
            var response = await client.GetAsync("https://api.coinlore.net/api/ticker/?id=" + id);

            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsStringAsync();
                var priceHistory = new List<PriceHistory>();

                try
                {
                    var data = JsonSerializer.Deserialize<List<Dictionary<string, object>>>(content);
                    if (data != null && data.Count > 0)
                    {
                        var item = data[0];
                        var nameId = item["nameid"]?.ToString()?.ToLower();
                        var symbol= item["symbol"]?.ToString();
                        var price = item["price_usd"]?.ToString();

                        // Step 2: Fetch historical data from CoinGecko
                        var chartUrl = $"https://api.coingecko.com/api/v3/coins/{nameId}/market_chart?vs_currency=usd&days=1";
                        var chartResponse = await client.GetAsync(chartUrl);
                        
                        if (!chartResponse.IsSuccessStatusCode)
                        {
                            // Fallback: Query local DB for historical prices
                            var oneDayAgo = DateTime.UtcNow.AddDays(-1);
                            var localHistory = await _db.PriceHistories.Where(p => p.CryptoId == id && p.Timestamp >= oneDayAgo).OrderByDescending(p => p.Timestamp).ToListAsync();
                            return Ok(new { currencyData = content, currencyHistory = localHistory });
                        }

                        var chartContent = await chartResponse.Content.ReadAsStringAsync();

                        var chartJson = JsonDocument.Parse(chartContent);
                        var prices = chartJson.RootElement.GetProperty("prices");

                        foreach (var pricePoint in prices.EnumerateArray())
                        {
                            var timestamp = DateTimeOffset.FromUnixTimeMilliseconds((long)pricePoint[0].GetDouble()).UtcDateTime;
                            var value = pricePoint[1].GetDecimal();

                            var record = new PriceHistory
                            {
                                CryptoId = id,
                                Symbol = symbol?.ToString() ?? "UNKNOWN",
                                Timestamp = timestamp,
                                Price = value
                            };

                            priceHistory.Add(record);
                            _db.PriceHistories.Add(record);
                        }

                        await _db.SaveChangesAsync();
                        return Ok(new { currencyData = content, currencyHistory = priceHistory });
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Failed to parse or store price: " + ex.Message);
                    return StatusCode(500, "Internal error while processing crypto data.");
                }

            }

            return StatusCode((int)response.StatusCode, "Failed to fetch data");
        }
        
        [HttpPost("AddMoney")]
        public async Task<IActionResult> AddMoney([FromForm] decimal amount, [FromHeader(Name = "X-Api-Key")] string apiKey)
        {
            var user = await GetUserByApiKeyAsync(apiKey);
            if (user == null)
                return Unauthorized("Invalid or missing API key: X-Api-Key=YOUR-API-KEY");

            var account = await _db.Accounts.FirstOrDefaultAsync(a => a.WalletId == user.WalletId);
            if (account == null)
                return NotFound("Account not found.");

            account.Balance += amount;
            await _db.SaveChangesAsync();

            return Ok(new { message = $"Successfully added {amount:C} to your balance.", newBalance = account.Balance });
        }

        /// <summary>
/// Initiates a Buy crypto transaction
/// </summary>
/// <param name="id">The Coinlore ID of the cryptocurrency</param>
/// <param name="apiKey">The API Key of the user initiating the transaction</param>
/// <returns>A response indicating the success or failure of the transaction</returns>
        [HttpPost("Buy")]
        public async Task<IActionResult> BuyCrypto([FromForm] int id, [FromHeader(Name = "X-Api-Key")] string apiKey, [FromForm] decimal amount)
        {
            return await HandleTransaction(id, apiKey, "buy", amount);
        }

        /// <summary>
        /// Initiates a Sell crypto transaction
        /// </summary>
        /// <param name="id">The Coinlore ID of the cryptocurrency</param>
        /// <param name="apiKey">The API Key of the user initiating the transaction</param>
        /// <returns>A response indicating the success or failure of the transaction</returns>
        [HttpPost("Sell")]
        public async Task<IActionResult> SellCrypto([FromForm] int id, [FromHeader(Name = "X-Api-Key")] string apiKey, [FromForm] decimal amount)
        {
            return await HandleTransaction(id, apiKey, "sell", amount);
        }

        /// <summary>
        /// Handles the buy/sell transactions and updates the user’s cryptocurrency balances
        /// </summary>
        private async Task<IActionResult> HandleTransaction(int id, string apiKey, string type, decimal amount)
        {
            var user = await GetUserByApiKeyAsync(apiKey);
            if (user == null)
                return Unauthorized("Invalid or missing API key: X-Api-Key=YOUR-API-KEY");

            var account = await _db.Accounts.FirstOrDefaultAsync(a => a.WalletId == user.WalletId);
            if (account == null)
                return NotFound("Account not found.");

            var response = await new HttpClient().GetAsync($"https://api.coinlore.net/api/ticker/?id={id}");
            if (!response.IsSuccessStatusCode)
                return StatusCode((int)response.StatusCode, "Failed to fetch currency info.");

            var content = await response.Content.ReadAsStringAsync();
            var data = JsonSerializer.Deserialize<List<Dictionary<string, object>>>(content);
            if (data == null || data.Count == 0)
                return NotFound("Currency not found.");

            var coin = data[0];
            var symbol = coin["symbol"].ToString()?.ToUpper();
            var priceUsd = decimal.Parse(coin["price_usd"].ToString() ?? "0");

            var totalCost = priceUsd * amount;

            if (type == "buy")
            {
                if (account.Balance < totalCost)
                    return BadRequest("Insufficient funds.");

                account.Balance -= totalCost;
                UpdateCryptoBalance(account, symbol, amount);
            }
            else if (type == "sell")
            {
                if (!HasSufficientCrypto(account, symbol, amount))
                    return BadRequest("Insufficient crypto balance.");

                UpdateCryptoBalance(account, symbol, -amount);
                account.Balance += totalCost;
            }
            else
            {
                return BadRequest("Invalid transaction type.");
            }

            _db.Transactions.Add(new Transaction
            {
                WalletId = user.WalletId,
                CryptoId = id,
                PriceAtTransaction = priceUsd,
                Type = type,
                DateTime = DateTime.UtcNow
            });

            await _db.SaveChangesAsync();

            return Ok($"Successfully {type}ed {amount} {symbol} at ${priceUsd} each.");
        }

        private async Task<User?> GetUserByApiKeyAsync(string apiKey)
        {
            if (!Guid.TryParse(apiKey, out Guid key))
                return null;

            return await _db.Users.FirstOrDefaultAsync(u => u.ApiKey == key);
        }

        private void UpdateCryptoBalance(Account account, string symbol, decimal amount)
        {
            switch (symbol)
            {
                case "BTC": account.Bitcoin += amount; break;
                case "ETH": account.Ethereum += amount; break;
                case "LTC": account.Litecoin += amount; break;
                case "XRP": account.Ripple += amount; break;
                default: account.OtherCrypto += amount; break;
            }
        }

        private bool HasSufficientCrypto(Account account, string symbol, decimal required)
        {
            return symbol switch
            {
                "BTC" => account.Bitcoin >= required,
                "ETH" => account.Ethereum >= required,
                "LTC" => account.Litecoin >= required,
                "XRP" => account.Ripple >= required,
                _ => account.OtherCrypto >= required
            };
        }
    }
}
