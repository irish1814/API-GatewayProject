using Microsoft.AspNetCore.Mvc;
using System.Text.Json;
using ApiGateway.Models.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.AI;


namespace ApiGateway.Controllers
{
    /// <summary>
    /// Controller responsible for handling API service calls including interaction with AI agents
    /// and cryptocurrency price tracking.
    /// Access this controller using http://hostip:5182/APIServices/{Operation}
    /// </summary>
    [Route("api/[controller]")]
    [ApiController]
    public class APIServicesController : Controller
    {
        private readonly CryptoDbContext _db;
        private readonly RedisCacheContext _redisCache;
        
        /// <summary>
        /// Initializes a new instance of the <see cref="UsersController"/> class with the specified database context.
        /// </summary>
        /// <param name="db">The database context used to access user data.</param>
        /// <param name="distributedCache">Redis database context used to access logged-in user data.</param>
        public APIServicesController(CryptoDbContext db, RedisCacheContext distributedCache)
        {
            _db = db;
            _redisCache = distributedCache;
        }

        /// <summary>
        /// Sends a prompt to a local TinyLlama model running at http://localhost:11434/api/generate
        /// and returns the AI-generated response.
        /// </summary>
        /// <param name="prompt">The prompt string to be processed by the AI agent.</param>
        /// <param name="apiKey">The API key identifying the user. Must be passed in the request header as 'X-Api-Key'.</param>
        /// <returns>Returns the response generated by the AI model or an error if the request fails.</returns>
        [HttpPost("Agent")]
        public async Task<IActionResult> AskLAgent([FromForm] string prompt, [FromHeader(Name = "X-Api-Key")] string apiKey)
        {
            var user = await GetUserByApiKey(apiKey);
            if (user == null)
                return Unauthorized("Invalid or missing API key: X-Api-Key=YOUR-API-KEY");

            OllamaChatClient chatClient = new OllamaChatClient(endpoint: new Uri("http://192.168.33.51:11434"), modelId: "tinyllama:latest");
            List<ChatMessage> chatHistory = [];

            chatHistory.Add(new ChatMessage(ChatRole.User, prompt));

            var response = "AI Agent Response: ";

            await foreach (var item in chatClient.GetStreamingResponseAsync(chatHistory))
            {
                Console.Write(item.Text);
                response += item.Text;
            }

            chatHistory.Add(new ChatMessage(ChatRole.Assistant, response));
            Console.WriteLine();

            return Ok(new { AgentResponse = response });
        }

        /// <summary>
        /// Fetches the current information of a cryptocurrency from the Coinlore API based on its ID,
        /// stores the price and symbol in memory, and logs the history to the console.
        /// </summary>
        /// <param name="id">The Coinlore ID of the cryptocurrency.</param>
        /// <param name="apiKey">The API key identifying the user. Must be passed in the request header as 'X-Api-Key'.</param>
        /// <returns>
        /// Returns the API response as-is if successful. Also appends the current price and symbol to
        /// the local in-memory history list.
        /// </returns>
        [HttpPost("CurrencyInfo")]
        public async Task<IActionResult> GetCryptoCurrencyInfo([FromForm] int id, [FromHeader(Name = "X-Api-Key")] string apiKey)
        {
            if (string.IsNullOrEmpty(id.ToString()))
                return BadRequest("Currency ID is required.");    
            
            var user = await GetUserByApiKey(apiKey);
            
            if (string.IsNullOrEmpty(apiKey) || user == null)
                return Unauthorized("Invalid or missing API key: X-Api-Key=YOUR-API-KEY");

            // Step 1: Fetch Currency data from CoinLore
            var client = new HttpClient();
            var response = await client.GetAsync("https://api.coinlore.net/api/ticker/?id=" + id);

            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsStringAsync();
                var priceHistory = new List<PriceHistory>();

                try
                {
                    var data = JsonSerializer.Deserialize<List<Dictionary<string, object>>>(content);
                    if (data != null && data.Count > 0)
                    {
                        var item = data[0];
                        var nameId = item["nameid"].ToString()?.ToLower();
                        var symbol= item["symbol"].ToString();

                        // Step 2: Fetch historical data from CoinGecko
                        var chartUrl = $"https://api.coingecko.com/api/v3/coins/{nameId}/market_chart?vs_currency=usd&days=1";
                        var chartResponse = await client.GetAsync(chartUrl);

                        // Fallback: Query local DB for historical prices
                        if (!chartResponse.IsSuccessStatusCode)
                        {
                            var oneDayAgo = DateTime.UtcNow.AddDays(-1);
                            var localHistory = await _db.PriceHistories
                                .Where(p => p.CryptoId == id && p.Timestamp >= oneDayAgo)
                                .OrderByDescending(p => p.Timestamp)
                                .ToListAsync();
                            
                            return Ok(new { currencyData = content, currencyHistory = localHistory });
                        }

                        var chartContent = await chartResponse.Content.ReadAsStringAsync();

                        var chartJson = JsonDocument.Parse(chartContent);
                        var prices = chartJson.RootElement.GetProperty("prices");

                        foreach (var pricePoint in prices.EnumerateArray())
                        {
                            var timestamp = DateTimeOffset.FromUnixTimeMilliseconds((long)pricePoint[0].GetDouble()).UtcDateTime;
                            var value = pricePoint[1].GetDecimal();

                            var record = new PriceHistory
                            {
                                CryptoId = id,
                                Symbol = symbol ?? "UNKNOWN",
                                Timestamp = timestamp,
                                Price = value
                            };

                            priceHistory.Add(record);
                            _db.PriceHistories.Add(record);
                        }

                        await _db.SaveChangesAsync();
                        return Ok(new { currencyData = content, currencyHistory = priceHistory });
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Failed to parse or store price: " + ex.Message);
                    return StatusCode(500, "Internal error while processing crypto data.");
                }

            }

            return StatusCode((int)response.StatusCode, "Failed to fetch data");
        }

        /// <summary>
        /// Retrieves a list of supported cryptocurrencies along with their
        /// respective values for the external API.
        /// </summary>
        /// <param name="apiKey">The API key identifying the user.
        /// Must be passed in the request header as 'X-Api-Key'.</param>
        /// <returns>
        /// An <see cref="IActionResult"/> containing a dictionary of supported currencies
        /// if the API key is valid; otherwise, returns <c>Unauthorized</c>.
        /// </returns>
        [HttpGet("SupportedCurrencies")]
        public async Task<IActionResult> GetCurrencyList([FromHeader(Name = "X-Api-Key")] string apiKey)
        {            
            var user = await GetUserByApiKey(apiKey);
            if(string.IsNullOrEmpty(apiKey) || user == null)
                return Unauthorized("Invalid or missing API key: X-Api-Key=YOUR-API-KEY");
            
            var currencyList = new Dictionary<string, int>
            {
                {"Bitcoin (BTC)", 90}, {"Ethereum (ETH)", 80}, {"Solana (SOL)", 48543},
                {"Ripple (XRP)", 58}, {"Litecoin (LTC)", 1}, {"Cardano (ADA)", 257}
            };
            
            return Ok(new { SupportedCurrencies = currencyList });
        }
        
        /// <summary>
        /// Retrieves a user object by their API key.
        /// Checks Redis cache first, then falls back to MySQL if not found.
        /// </summary>
        /// <param name="apiKey">The API key associated with the user.</param>
        /// <returns>
        /// A <see cref="User"/> object if found; otherwise null.
        /// </returns>
        private async Task<User?> GetUserByApiKey(string apiKey)
        {
            var cachedUser = await _redisCache.GetUserByApiKey(apiKey);

            if (cachedUser != null)
            {
                // Parse or return cached data
                return cachedUser;
            }
            
            Console.WriteLine("Fetching user from MySQL");
            var user = await _db.Users.FirstOrDefaultAsync(u => u.ApiKey == Guid.Parse(apiKey));
            
            if(user == null)
                return null;
            
            await _redisCache.SetUserByApiKey(apiKey, user);
            return user;
        }
    }
}
